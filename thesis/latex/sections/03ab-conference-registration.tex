\subsection{POC 2: Auto-Complete Form Inputs for Conference Registration in Indico}

The second prototype aims at connecting Solid with the conference registration module in Indico. When registering for a conference an \gls{html} form is presented with fields previously defined by the conference manager, who deemed those fields necessary. A form always contains personal information of name and email address, but is not limited to it and can even range to more sensitive information such as copies of personal identification documents. Information of this type has perfect motivation to remain in the hand of the owner and not be stored in a remote data store, uncontrollable and unknown to the registrants.

Therefore, the initial aim was to extend the registration module to allow storage of sensible information in a data pod, where the user has full control and can handle the data to their own liking. This was decided to not be viable and the prototype changed to allow the extraction of data from a data pod and then use this data to map it to input fields of an Indico conference registration form -- the functionality to then also store the data from the registration in the user's data pod and not in Indico was dropped. The reasons and comprehensive analysis will be shared after the architectural analysis, synthesis, and evaluation of the developed \gls{poc} in the \textit{design} \ref{poc2:design} and \textit{analysis} \ref{poc2:analysis} sections of this chapter.

\subsubsection{Architectural Analysis and Synthesis}\mbox{}\\

\paragraph{System Description}\mbox{}\\

The system pulls in a resource from a data pod in the \gls{rdf} format Turtle, maps the received information to input fields in an \gls{html} form and fills in missing inputs or asks the user if the values should be replaced.

\vspace{0.5cm}
\paragraph{Features}\mbox{}\\

The core functionality of the module consists of the following features: 

\vspace{-3mm}
\begin{enumerate}
    \item A user can provide a the \gls{uri} to a public Turtle file
    \item A user can choose to accept or reject values pulled in when values already exist
\end{enumerate}
\vspace{-3mm}

These features allow the development of a module giving users the ability to pull in their WebID profile document and use the information provided in it to populate a conference registration.
\vspace{0.5cm}
\paragraph{Type of Users}\mbox{}\\

There is one type of user for this system, who is the user with a WebID profile and interested in using the existing information to fill in a form.
\vspace{0.5cm}
\paragraph{Context Diagram}\mbox{}\\

Other types of involved parties are the ones maintaining or developing the system and application. These are shown in the context diagram \ref{fig:poc-autocomplete-context_diagram}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{prototype/graphs/poc-autocomplete-context_diagram.png}
    \caption{Context diagram showing users and external services of the system.}
    \label{fig:poc-autocomplete-context_diagram}
\end{figure}
\vspace{0.5cm}
\paragraph{Sequence Diagram}\mbox{}\\

The following succeeding diagram shows the sequential flow through the system upon initialization and button press. The focus was laid in the diagram to show the request/response cycles in the infrastructure. 

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{prototype/graphs/poc-conference_registration-autocomplete-sequence_diagram.png}
    \caption{Sequence diagram showing the sequential process through pulling in data from a data pod.}
    \label{fig:poc-conference_registration-autocomplete-sequence_diagram}
\end{figure}

\vspace{0.5cm}
\paragraph{Stakeholders}\mbox{}\\

Both modules were established with the same group of people and therefore carry the same set of stakeholders. The stakeholders defined in the section of the first \gls{poc} can be found here \cite{poc1-stakeholders}.
\vspace{0.5cm}
\paragraph{Drivers}\mbox{}\\

The drivers for this architecture endure the same as well. A system which operates on a form where sensitive data is exposed needs a high-level of security -- under no circumstance should traffic be intercepted and leak any of such information. The performance for this module is also important, as conference tend to open their registration at a certain time, with high traffic spikes at those times of registration opening or announcements. The same reasoning as before applies to the \textit{Usability} of the module. When a new software design is used, it should be made as simple as possible for the user to interact with it and ideally not even notice a difference to traditional practices.

\begin{enumerate}
    \item Security
    \item Performance
    \item Usability
\end{enumerate}

\subsubsection{User Interface}\mbox{}\\

The user interface for this module is rather limited as it only requires an input field for the user to provide the \gls{uri} of where to find an \gls{rdf} document that can be used to fill in the registration form, an action button and then a design for when two values on an input are probable.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{prototype/poc-solid-autocomplete-conference-registration.png}
    \caption{User interface showing the autocomplete module.}
    \label{fig:poc-solid-autocomplete-conference-registration}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{prototype/poc-solid-autocomplete-conference-registration-attendees.png}
    \caption{The Indico control panel showing registered users.}
    \label{fig:poc-solid-autocomplete-conference-registration-attendees}
\end{figure}

\subsubsection{Design}\label{poc2:design}\mbox{}\\

The following section will shed light on the design decision made in the process of sketching out the architecture of the module and developing the system. It will introduce the different challenges and how they were overcome. Especially, it will give an explanation of what led to the change of core functionality of the module. In the succeeding section, the choices will be analyzed more explicitly.
\vspace{0.5cm}
\paragraph{Mapping Structured Data To \gls{html} Inputs}\mbox{}\\

A great benefit of using Linked Data is its semantic structure and the interoperability it brings when using in systems supporting it. This means the data are using public vocabularies to be described and thus can be reasoned about by machines and can be move from one system into another one and seamlessly integrated. Indico does not make use of any common \gls{rdf} features and can therefore not extract any of those benefits. Because of this, no simple way of mapping the incoming data from the data pod to the inputs exist, but a few options are feasible.

\begin{enumerate}
    \item Enrich the form with some kind of descriptive indicator
    \item Parse and process existing values of attributes and labels
\end{enumerate}

In the \gls{html} specification an \texttt{autocomplete} attribute exist, which is used by browsers to prefill data from previously used values \cite{html-spec}. The value of the \texttt{autocomplete} key-value pair describes the input and what data is to be expected.

\begin{lstlisting}[language=Other,columns=fullflexible, caption={Autocomplete attribute on input field}, label={lst:autocomplete-input}]
<form method=post action="/">
  <p><label>Full name: <input type=text autocomplete=name></label>
  <p><label>Credit card number: <input type=text inputmode=numeric autocomplete=cc-number></label>
  <p><label>Expiry Date: <input type=month autocomplete=cc-exp></label>
  <p><input type=submit value="Submit">
</form>
\end{lstlisting}

In listing \ref{lst:autocomplete-input} the browser would suggest cached values when the user agent clicks into an input. This is the perfect indicator to \textit{autofill} form inputs. Unfortunately, this attribute is not being utilized in Indico. Another and even better approach would be to annotate the input fields straight up with the vocabulary of Schema.org \cite{schema-org}. The mapping of the input fields and the fetched Turtle resource could then happen directly using the \textit{predicates} of both structured formats. To change the AngularJS form and implement new features into Indico were already established not to be viable. Nevertheless, the \texttt{autocomplete} feature shall be kept in mind.

Without being able to extract from the \texttt{autocomplete} attribute within Indico it shall still be implemented and used, as other systems might use the attribute. Other means of extracting some kind of information from the form are the ID and name attributes or even the \texttt{TextNode} of the input label. The ID and name are often equipped with information about the input they are defined on. These values and additionally the value of the label node can be extracted and mapped against a dictionary of key-value pairs to find out what the input is supposed to be filled in with.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{prototype/graphs/poc-autocomplete-mapping-flow.png}
    \caption{The flow to find a source for dictionary mapping.}
    \label{fig:poc-autocomplete-mapping-flow}
\end{figure}

A possible mapping of address information could look like as in listing \ref{lst:autocomplete-mapping}. The implementation shows a \gls{js} implementation where the key in the \texttt{address} object are the possibly extracted values from the different techniques described above and the value is in this example the vCARD \cite{vcard-spec} equivalent. vCARD is being used by the \gls{nss} to describe the information in the WebID profile document.

\begin{lstlisting}[language=Other,columns=fullflexible, caption={Dictionary to map extracted values with predicates from Turtle resource}, label={lst:autocomplete-mapping}]
const address = {
  address: 'full_address',
  country: VCARD.country_name.value,
  countryName: VCARD.country_name.value,
  region: VCARD.region.value,
  locality: VCARD.locality.value,
  city: VCARD.locality.value,
  streetAddress: VCARD.street_address.value,
  street: VCARD.street_address.value,
  postalCode: VCARD.postal_code.value
}
\end{lstlisting}

Listing \ref{lst:webid-address} shows part of the WebID profile document where the address of an agent is described.

\begin{lstlisting}[language=Other,columns=fullflexible, caption={Extraction from WebID profile document showing address.}, label={lst:webid-address}]
@prefix : <#>.
@prefix n: <http://www.w3.org/2006/vcard/ns#>.
# ...
:id1614172452178
  n:country-name "Denmark";
  n:locality "Copenhagen";
  n:postal-code "2300";
  n:region "Zealand";
  n:street-address "Rued Langgaards Vej 18". 
# ...
:me n:hasAddress :id1614172452178;
# ...
\end{lstlisting}

\vspace{0.5cm}
\subsubsection{Integration With Indico}\mbox{}\\

A few challenges arose when integrating the module with Indico. A critical issue was when it was found out that the form is not rendered on the server and send as \gls{html} in the response body as expected. Another challenge was when programmatically filling in the input fields of the inputs the frontend form validation would not detect a change in the input values and thus would think no input value is given.

\vspace{0.5cm}
\paragraph{Bind to Dynamically Created Form}\label{poc2-bind}\mbox{}\\

Indico builds the registration form dynamically using a frontend library called AngularJS \cite{angularjs}. This introduces a challenge of interacting with the form using \gls{js}. Frontend libraries that either create new or modify existing \gls{dom} nodes need to wait until the complete \gls{dom} tree is loaded, as they bind to one \gls{dom} node from the initially served \gls{html} document and then do their operations on this node. Meaning, AngularJS waits until the whole \gls{html} document is parsed and rendered in the browser and then starts creating its form from scratch, which is then being rendered by the browser. The problem with this is in order to operate on the form, which is necessary for the module to be able to read the form inputs and labels and also to set their values, the \gls{js} code from this prototype needs to know when the form was successfully rendered. Three options are possible to achieve this.

\begin{enumerate}
    \item Implement the autocomplete functionality in the existing AngularJS form code
    \item Dispatch an event to notify the autocomplete module the form has been rendered
    \item Use the \texttt{MutationObserver} to detect the form creation
\end{enumerate}

Solutions 1 and 2 both involve the need to work with the AngularJS form, which is written in a legacy version and was recommended by an Indico developer to -- if possible -- be avoided. Indico developers also plan on removing AngularJS altogether and replace it with a more popular frontend framework. Therefore, option 3 was chosen even though the usage of a \texttt{MutationObserver} instance might add performance degradation to the page load \cite{dom-spec}. The performance shall not be analyzed more carefully as it is not of relevance to prove the realization of the prototype.

The \texttt{MutationObserver} is initialized as soon as the \gls{dom} is rendered, it then takes a node as a target to observe and will register all modifications on this node: the creation of children nodes in it, updates to the node itself or any other modifications. To reduce computation the Indico code can be analyzed to find a suitable \gls{dom} element to have as a target node. This node needs to exist when the \gls{dom} is loaded and needs to contain the final form node. When looking at the final rendered document containing the AngularJS form one notices that the form has an ID, which can be used to observe its creation.
 
\begin{lstlisting}[language=Other,columns=fullflexible, caption={Observe function in Indico}, label={lst:indico-observe}]
function observeFormCreation() {
  // ID of the AngularJS form, its creation needs to be observed
  const formId = 'registrationForm';
  // Candidate to limit observing scope
  const $conferencePage = document.querySelector('.conference-page');
  const targetNode = $conferencePage;
  // Only observe nodes, not attributes
  const config = {attributes: false, childList: true, subtree: true};

  const callback = (mutationsList, observer) => {
    // Contains all mutations in the targetNode
    for (const mutation of mutationsList) {
      // Node has beed added or removed
      if (mutation.type === 'childList') {
        // Look at all added nodes
        for (const node of mutation.addedNodes) {
          // Look for the AngularJS form
          if (node.id === formId) {
            // Once found, stop observing
            observer.disconnect();
            // Initialize the autocomplete library
            const solidAutocomplete = new SolidAutocomplete({form: node});
            solidAutocomplete.createAutocompleteDomControls(node);
          }
        }
      }
    }
  };
  // Start observing
  const observer = new MutationObserver(callback);
  observer.observe(targetNode, config)
}
\end{lstlisting}

\vspace{0.5cm}
\paragraph{Detect Input Change for Frontend Validation}\label{poc2-detect-input}\mbox{}\\

Indico deploys a frontend validation to make sure it receives proper values for the form's inputs. A basic validation is the check for a presence of values in required inputs. This way Indico can render a hint on the input fields with invalid values, such as if no input was given in a required email address field. It turns out Indico has \texttt{\gls{dom} Event Listeners} which detect if an input field is clicked in and if it is receiving inputs through a user typing in it. This validation implementation does not detect when changing the value of the \texttt{value} attribute of an input node, thus complaining when setting the values through \gls{js}.

\begin{lstlisting}[language=Other,columns=fullflexible, caption={Changing the value of an input node.}, label={lst:input-change}]
const formInputField = document.querySelector('.exampleFormInput')
formInputField.value = 'New value'
\end{lstlisting}

The example code in listing \ref{lst:input-change} would not be detected by Indico and would upon submission render a missing value hint.

Two ways of fixing the problem are conceivable.

\begin{enumerate}
    \item Change Indico frontend validation to detect value change
    \item Dispatch event when setting values in the autocomplete module
\end{enumerate}

Changing the Indico frontend validation might turn out to be more time-consuming than anticipated and is therefore not viable, also it is unknown if a change is wanted by the Indico development team in the first place. The idea for a working implementation is to validate on submission of the form instead of validation when a change on the input is detected. As mentioned before the problem with the used \texttt{oninput} event is it does not detect when the value is set programmatically. If the validation is only happening when the values are tried to be sent to the server by submission the input values can be parsed and the correct value is detected -- no matter how it was set. 

The other and also picked solution is to trigger the \texttt{oninput} event that is being listened on by the Indico validation. The event dispatch needs to happen as soon the values are set within the module and because this happens in the module and the module is a self-contained module without any knowledge of Indico, the module should not be directly changed, but rather allow a callback function to be passed to it and then execute when appropriate.

\begin{lstlisting}[language=Other,columns=fullflexible, caption={Dispatching the \texttt{oninput} event within a callback.}, label={lst:oninput-callback}]
function triggerInputEvent(inputs) {
  for (let i = 0; i < inputs.length; i++) {
    const element = inputs[i];
    [element, element.parentNode].forEach(node => {
      if ('createEvent' in document) {
        const evt = document.createEvent('HTMLEvents');
        evt.initEvent('input', false, true);
        node.dispatchEvent(evt);
      } else {
        node.fireEvent('oninput');
      }
    });
  }
}
\end{lstlisting}

\subsubsection{Evaluation}\mbox{}\\

Just like with the first \gls{poc} from a section before \ref{poc1}, this \gls{poc} shall be evaluated using the same motivation and framework. The stakeholders and \glspl{qa} continue to be as is. An 
TODO:
\vspace{0.5cm}
\paragraph{Metrics}\mbox{}\\

The previously picked \glspl{qa} are as follows:

\begin{enumerate}
    \item Security
    \item Performance
    \item Usability
\end{enumerate}

The \glspl{qas} to make the \glspl{qa} measurable allowing the analysis of health in the system's architecture:

\begin{enumerate}
    \item As a user I expect to see the information from my WebID profile document when using the module
    \item As a user I expect to have the choice on two available values
    \item As a user I expect to be incapable of pulling in protected resources without authenticating myself
\end{enumerate}
\vspace{0.5cm}
\paragraph{Levels}\mbox{}\\

The same levels 1 to 5 as in the first evaluation \ref{section:poc1-evaluation} will be used to rate the architecture of this system.
\vspace{0.5cm}
\paragraph{Components}\mbox{}\\

This module is compared to the other module relatively small and does not contain multiple packages. It forms through the three key classes \texttt{Picker}, \texttt{Mapper}, and \texttt{Filler}. These three classes as they hint at find all relevant input fields from the application that will be used; secondly maps the input fields with the available data fetched using the \texttt{DataFetcher} class; thirdly it fills the available data through the mapping into the input fields.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{prototype/graphs/poc-autocomplete-package.png}
    \caption{The classes in the autocomplete module.}
    \label{fig:poc-autocomplete-package}
\end{figure}
\vspace{0.5cm}
\paragraph{Evaluate}\mbox{}\\

\begin{itemize}
    \item \textbf{Target}: What is the desired quality level?
    \item \textbf{Current}: What is the current level?
    \item \textbf{Health}: Where are the largest quality problems?
    \item \textbf{Importance}: How important is it to move from current to target level?
    \item \textbf{Focus}: What are the largest and most important quality problems?
    \item \textbf{Valid level values}: 1, 2, 3, 4, 5 (higher equals better)
\end{itemize}

\textbf{Health} and \textbf{focus} are not set by the evaluator but rather calculated from other levels.

\begin{align*}
    \text{\textit{health}}&=5 - \text{\textit{max}}(0, (\text{\textit{target}} - \text{\textit{current}}))
\end{align*}
\vspace{-5mm}
\begin{align*}
    \text{\textit{focus}}&= \text{\textit{ceil}}((6 - \text{\textit{health}}) * \text{\textit{importance}}/5)
\end{align*}

\begin{enumerate}
    \item A user enters their WebID \gls{uri} and presses \textit{autocomplete}
    \item A user enters someone else's WebID \gls{uri} and presses \textit{autocomplete}
    \item A user enters a \gls{uri} with a protected resource and presses \textit{autocomplete}
    \item An adversary enters a \gls{uri} to a malicious document
\end{enumerate}

\begin{table}[h!]
    \centering
    \begin{tabular}{| l | c | c | c | c | c |} 
     \hline
     \texttt{autocomplete} & T & C & H & I & F \\
     \hline
     Security & 5 & 5 & 5 & 5 & \cellcolor{green!25}1\\
     \hline
     Performance & 3 & 3 & 5 & 3 & \cellcolor{green!25}2\\
     \hline
     Availability & 2 & 3 & 5 & 1 & \cellcolor{green!25}1\\
     \hline
     Usability & 5 & 2 & 2 & 5 & \cellcolor{red!25}4\\
     \hline
    \end{tabular}
    \vspace{0.75cm}
    \caption{Evaluation of the autocomplete module based on the \glspl{qas}}
    \label{table:poc2-evaluation}
\end{table}
\subsubsection{Analysis}\label{poc2:analysis}\mbox{}\\

The analysis of the second \gls{poc} will explain the evaluation matrix \ref{poc2:evaluation} and then focus on the original design idea and what led to a change of mind. It will do so by looking at the relevant modules in Indico that caused the direction for the \gls{poc} to alter. It will also be analyzed, what role Solid's design played in the abandonment of the idea on storing the registration data in data pods and effectively giving up usage control.

\vspace{0.5cm}

Because the module does not use any authentication libraries to give users the opportunity to log in or store any data in a data pod. It simply fetches public documents, where the user interacting with the module decides what to fetch, no risk is involved. In regards to pulling in malicious documents from a thought trustworthy source the module is embedded into Indico which has validations and makes sure no malicious code is injected into their system.
The performance of the module is also in good shape. Only one request happens when the system is doings its tasks. The dictionary for the mapping of values uses the \gls{js} \texttt{Object} data type. It allows constant $\bigO(1)$ look ups of values. See listing \ref{lst:autocomplete-mapping} to see an example data store of values. One area of improvement for the performance is the \texttt{MutationObserver} that was explained in paragraph \ref{poc2-bind}. Indico throws an event when all dynamically created \gls{dom} elements have been rendered, which is perfect for the binding of the module to the Indico form. It was only later noticed this event exists.
\vspace{0.5cm}
\paragraph{Iterations}\mbox{}\\

As mentioned before this module went through two iterations of design. Up until the point of creating the architecture of the actual module it was undiscovered that the development of a module that sits on the registration form and allows the decentralized storage is not viable. In figure \ref{fig:poc-conference_registration_flow-sideways} the exact flow through the conference registration with Solid is shown. It checks if the user wants to register regularly and let Indico have and handle the registration data or if the user wants to use their WebID and thus store the data in their own data pod for maximum usage control.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{prototype/graphs/poc-conference_registration_flow-sideways.jpeg}
    \caption{Flow through the registration flow using Solid account.}
    \label{fig:poc-conference_registration_flow-sideways}
\end{figure}

A few challenges were unidentified at this point, but will be named and explained now.
\vspace{0.5cm}
\paragraph{Modification of Resource From Data Pod}\mbox{}\\

As also realized in the first \gls{poc} when the application is decoupled from the data and receives it upon request the application hands over the control. This shift of control is core concept in Solid, but problematic for Indico. The use-case of registration data differs with the handling of comments. Comments are often desired to be changed and mostly comments are just presented in the user interface an no other interaction or processing happens. Registration data is much more complex and requires a lot of processing, such as the submission of abstracts. \textit{Call for abstracts} is a workflow in Indico, where conference speakers need to upload an abstract about the conference talk. Another are requirement for processing is the field of payments in the registration. A registration form can offer users an option to book an accommodation for example. These fields are called \textit{billable} fields and are hooked into a checkout process. In Indico's management section of a conference these actions can be checked for status.

\begin{enumerate}
    \item What happens now if this data is not kept in Indico anymore?
    \item How is Indico validating a registrant has actually payed their bookings, if all registration information is kept outside of Indico?
    \item What happens to generated registration tickets or receipts when a user changes the name on their data pod?
\end{enumerate}

Indico allows the editing of the registration up until a set modification deadline, after it the registration is frozen and fields cannot be updated. It is necessary to have time to process the registrations, such as the booking of an accommodation. The classic setup where every user has their own data pod to store all this registration data would not work without additional functionality. A few things are imaginable.

\begin{itemize}
    \item Store a copy of the registration data in Indico and freeze the copy on modification deadline.
    \item Only allow decentralized storage on data where a modification would not matter
\end{itemize}

Storing a copy of the data is an interesting idea. The freezing of the data would of course require Indico to also save the data in their data stores. If data is modified directly on the data pod, Indico is not necessarily notified by the change. If the latest data should be used in Indico for freezing its own copy, Indico would have to be either notified so it can fetch the new resource from the data pod; the change needs to happen through Indico's web interface, so Indico can send the request to update it in the data pod, but also in their storage; Indico sends a request to all data pods on modification deadline day and updates the stored version. The latter solution of course needs validation, so that existing is not replaced with corrupt or invalid data, and it is also questionable what happens when the data pod is unavailable, but the data shows a resignation from the conference or anything similar. How is ensured that Indico and the user's intentions are aligned? The two systems need to be interconnected and it needs to be clear when updates happen. Availability and flow of communication or key aspects for this success.
\vspace{0.5cm}
\paragraph{Communication Flow}\mbox{}\\

Not to cut off the previous issue, but to continue and nurture the aspect of flow in Solid. One crucial feature of conferences and the registration is the ability to reach out to people to let them know about next year's conference for instance. Consent would ideally only be given to the conference where one had actively sign up for and hence next year's conference would not be able to read the participant's list and connect with them and even if the list would be visible, how does the new conference know how to ask for consent to reach out them or do akin actions. Solid offers an \textit{inbox} and \textit{notifications} \cite{solid-inbox}. Solid-Inbox allows anyone in the Solid ecosystem with the public \textit{append} access control to connect with a WebID. The reached out agent gets a notification as soon as a new item is appended into their inbox. This pro-active initiation is not ideal, as the initiator does not know what data can be asked for. Only when owner actively says: “You are allowed to read this resource A and modify my resource B.”, does the application know about the existence of the data.

Solid-Inbox seems to be a decent solution for the use-case of Indico reaching out to previous participants. Another suggestion would be to escalate the access scope for Indico and conferences and the agent. Meaning, when a user signs up for a conference the registration asks for consent to allow future contacting.
TODO: more here
\vspace{0.5cm}
\paragraph{Performance of Large Conference}\mbox{}\\

The identical performance issue from the first \gls{poc} \ref{poc1} would arise in the management part of the conference. Storing the source of truth for hundreds of registrations without a local copy in a remote data pod would mean they would have to fetched. Even with the improvements of caching this would still be problematic and would just not be feasible -- pods can be down or stored on slow web servers. To make this usable in Indico a proxy is definitely compulsory. The proxy would store the information temporarily and could make it available in a single request for multiple conference managers on separate machines. Warming up the cache by requesting resources from hundreds of data pods would still take a long time. 
The key takeaway here is that Indico is also \textit{serving} data to users. Indico is not only taking in the registration data and then processes it and enables some feature for a single user who is only interacting with his own data. On the contrary Indico also serves to a subset of users, the conference managers, data. The progress of serving the data from others is the critical facet.
\vspace{0.5cm}
\paragraph{Payment on Input Fields}\mbox{}\\

TODO:


* Gave up usage control
  * Why it didn't work, and **what is necessary to make it work**
    * usage control
    * question the choice of Indico usage control
    * versioning of tag of personal data
* high-level constraints
* implementation
  * indico limits this
* if indico in this way or more generally

TODO:
1st iteration, save data in pod
2nd iteration, only pull data from pod

TODO: Include these somehow:

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{prototype/graphs/poc-conference_registration_flow-client_side-sideways.jpeg}
    \caption{TODO:}
    \label{fig:poc-conference_registration_flow-client_side-sideways}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{prototype/graphs/poc-conference_registration_flow-server_side-sideways.jpeg}
    \caption{TODO:}
    \label{fig:poc-conference_registration_flow-server_side-sideways}
\end{figure}

\vspace{0.5cm}
\paragraph{Availability of Crucial User Data}\mbox{}\\

TODO


* performance?
* Management part of Indico
  * Forward data between people
  * **Also serve data to people (admin of registration)**
* Comments are more clear tied to comment?

* Indico does not have any RDF semantically structured data